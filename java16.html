<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The volatile Keyword in Java Multithreading</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <p>In Java, the <code>volatile</code> keyword is used to declare a variable as volatile. When a variable is marked as volatile, it ensures that any read or write operation on the variable is directly performed on the main memory, rather than using a thread's local cache. This makes the variable's value visible to all threads, ensuring thread safety in certain scenarios.</p>

    <h2>Key Concepts:</h2>
    <ul>
        <li><strong>Visibility:</strong> The volatile keyword ensures that changes made to a volatile variable by one thread are immediately visible to other threads.</li>
        <li><strong>Atomicity:</strong> While volatile ensures visibility, it does not guarantee atomicity for compound operations (e.g., incrementing a volatile variable is not an atomic operation).</li>
    </ul>

    <h2>Usage of the volatile Keyword:</h2>
    <p>The volatile keyword is typically used for flags or variables that are accessed by multiple threads, and where the value of the variable should always be read from and written to the main memory. It is not used for complex operations that require atomicity.</p>

    <h2>Common Use Cases:</h2>
    <ul>
        <li><strong>Stopping a Thread:</strong> The volatile keyword can be used to signal a thread to stop by setting a volatile boolean flag. When another thread sets the flag, it notifies the first thread to stop its execution.</li>
        <li><strong>Double-Checked Locking:</strong> In some cases, volatile can be used to implement the double-checked locking pattern for lazy initialization of singletons.</li>
    </ul>

    <h2>Example:</h2>
    <pre><code>
public class VolatileExample {
    private volatile boolean flag = false;

    public void toggleFlag() {
        flag = !flag; // Toggle the flag
    }

    public boolean isFlag() {
        return flag;
    }

    public static void main(String[] args) {
        VolatileExample example = new VolatileExample();

        Thread writerThread = new Thread(() -> {
            example.toggleFlag();
            System.out.println("Flag is set to true.");
        });

        Thread readerThread = new Thread(() -> {
            while (!example.isFlag()) {
                // Wait for the flag to become true
            }
            System.out.println("Flag is true. Exiting.");
        });

        writerThread.start();
        readerThread.start();
    }
}
    </code></pre>

    <p>In this example, a class <code>VolatileExample</code> contains a volatile boolean flag. One thread sets the flag to true using <code>toggleFlag()</code>, and another thread waits until the flag becomes true using <code>isFlag()</code>. The use of the <code>volatile</code> keyword ensures that changes to the flag are immediately visible to both threads.</p>

</body>
</html>